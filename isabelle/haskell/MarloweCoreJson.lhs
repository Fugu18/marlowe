{-
    This module adds Json encoding and decoding capabilities
    to the SemanticTypes generated by Isabelle.

    It is written with Literal Haskell to be both the actual code
    and part of the specification.
-}

-- To use lhs2TeX we need to include the "template" of tex generation
%include polycode.fmt

-- We configure ghci to include the relevant files so that \eval can print
-- them
%options ghci -iisabelle/generated:isabelle/haskell

-- The tex that this file generates includes all the necesary directives
-- to be called by pdflatex directly, but we are actually including this
-- inside of the specification that Isabelle generates, so we need to
-- provide a...
-- ===PATTERN FOR SED===

%if False
-- Everything inside the `if False` block is not seen by lhs2TeX but is
-- seen by Haskell.
\begin{code}
{-# LANGUAGE OverloadedStrings #-}

module MarloweCoreJson where

import Control.Applicative ((<|>), (<*>))
import CoreOrphanEq
import Data.Aeson (object, withObject, (.=), (.:), encode)
import Data.Aeson.Types (ToJSON(..), FromJSON(..))
import qualified Data.ByteString.Lazy as L
import qualified Data.ByteString.Lazy.Char8 as C
import SemanticsTypes (Party(..), Token(..), Payee(..))

encodeExample :: ToJSON a => a -> IO ()
encodeExample a = putStrLn $ C.unpack $ encode a
\end{code}
%endif

The Json specification for Marlowe Core is defined in Literate Haskell using the Aeson library. In order
to fully understand the specification, some knowledge of Haskell and the library is recommended but not necessary.
\par

For each Marlowe datatype we define a way to parse the JSON into a value (FromJSON instances) and a way to serialize a
value to JSON (ToJSON instances).

\isamarkupsection{Party}

Parties are serialized as a simple object with an \emph{address} or \emph{role\_token} key, depending on the
\emph{Party} type.
\par

\begin{code}
instance ToJSON Party where
    toJSON (Address address) =
        object ["address" .= address]
    toJSON (Role name) =
        object ["role_token" .= name]

instance FromJSON Party where
    parseJSON = withObject "Party" $
        \v -> asAddress v <|> asRole v
      where
      asAddress v = Address <$> v .: "address"
      asRole v = Role <$> v .: "role_token"

\end{code}
\par

for example, the following \emph{Party}

\begin{code}
addressExample :: Party
addressExample = Address "example address"
\end{code}

is serialized as \eval{encodeExample addressExample}, and

\begin{code}
roleExample :: Party
roleExample = Role "example role"
\end{code}
\par

is serialized as \eval{encodeExample roleExample}

\isamarkupsection{Token}

The \emph{Token} type is serialized as an object with two properties, \emph{currency\_symbol} and
\emph{token\_name}


\begin{code}

instance ToJSON Token where
  toJSON (Token currSym tokName) = object
      [ "currency_symbol" .= currSym
      , "token_name" .= tokName
      ]


instance FromJSON Token where
  parseJSON = withObject "Token"
    (\v ->
       Token <$> (v .: "currency_symbol")
             <*> (v .: "token_name")
    )

\end{code}

for example, the following \emph{Token}

\begin{code}

dolarToken :: Token
dolarToken = Token "85bb65" "dolar"
\end{code}

is serialized as \eval{encodeExample dolarToken}

\isamarkupsection{Payee}

Payees are serialized as a simple object with an \emph{account} or \emph{party} key, depending on the
\emph{Payee} type.
\par

\begin{code}
instance ToJSON Payee where
    toJSON (Account account) =
        object ["account" .= account]
    toJSON (Party party) =
        object ["party" .= party]

instance FromJSON Payee where
    parseJSON = withObject "Payee" $
        \v -> asAccount v <|> asParty v
      where
      asAccount v = Account <$> v .: "account"
      asParty v = Party <$> v .: "party"

\end{code}

for example, the following \emph{Payee}

\begin{code}
internalPayeeExample :: Payee
internalPayeeExample = Account addressExample
\end{code}

is serialized as \eval{encodeExample internalPayeeExample}, and

\begin{code}
externalPayeeExample :: Payee
externalPayeeExample = Party roleExample
\end{code}
\par

is serialized as \eval{encodeExample externalPayeeExample}
