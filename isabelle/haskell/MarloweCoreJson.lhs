{-
    This module adds Json encoding and decoding capabilities
    to the SemanticTypes generated by Isabelle.

    It is written with Literal Haskell to be both the actual code
    and part of the specification.
-}

-- To use lhs2TeX we need to include the "template" of tex generation
%include polycode.fmt

-- We configure ghci to include the relevant files so that \eval can print
-- them
%options cabal exec ghci -- -iisabelle/generated:isabelle/haskell

-- The tex that this file generates includes all the necesary directives
-- to be called by pdflatex directly, but we are actually including this
-- inside of the specification that Isabelle generates, so we need to
-- provide a...
-- ===PATTERN FOR SED===

%if False
-- Everything inside the `if False` block is not seen by lhs2TeX but is
-- seen by Haskell.
\begin{code}
{-# LANGUAGE OverloadedStrings #-}

module MarloweCoreJson where

import Arith (Int(..))
import qualified Arith
import Control.Applicative ((<|>), (<*>))
import CoreOrphanEq
import ArithNumInstance
import Data.Aeson (object, withObject, withText, withScientific, (.=), (.:), encode)
import Data.Aeson.Types (Parser, ToJSON(..), FromJSON(..))
import qualified Data.Aeson.Types as JSON
import Data.Aeson.Encode.Pretty (encodePretty)
import qualified Data.ByteString.Lazy as L
import qualified Data.ByteString.Lazy.Char8 as C
import qualified Data.Text as T
import Data.Scientific (Scientific, floatingOrInteger)
import SemanticsTypes (Party(..), Token(..), Payee(..), ChoiceId(..), ValueId(..), Value(..), Observation(..))

-- These are some helper functions to print and pretty print a ToJSON example
encodeExample :: ToJSON a => a -> IO ()
encodeExample a = putStrLn $ C.unpack $ encode a

prettyEncodeExample :: ToJSON a => a -> IO ()
prettyEncodeExample a = putStrLn $ wrapInVerbatim $ C.unpack $ encodePretty a
    where
    wrapInVerbatim :: String -> String
    wrapInVerbatim str = "\\begin{verbatim}" ++ str ++ "\\end{verbatim}"

\end{code}
%endif

The Json specification for Marlowe Core is defined in Literate Haskell using the Aeson library. In order
to fully understand the specification, some knowledge of Haskell and the library is recommended but not necessary.
\par

For each Marlowe datatype we define a way to parse the JSON into a value (FromJSON instances) and a way to serialize a
value to JSON (ToJSON instances).

\isamarkupsection{Party}

Parties are serialized as a simple object with an \emph{address} or \emph{role\_token} key, depending on the
\emph{Party} type.
\par

\begin{code}
instance ToJSON Party where
    toJSON (Address address) =
        object ["address" .= address]
    toJSON (Role name) =
        object ["role_token" .= name]

instance FromJSON Party where
    parseJSON = withObject "Party" $
        \v -> asAddress v <|> asRole v
      where
      asAddress v = Address <$> v .: "address"
      asRole v = Role <$> v .: "role_token"

\end{code}
\par

for example, the following \emph{Party}

\begin{code}
addressExample :: Party
addressExample = Address "example address"
\end{code}

is serialized as \eval{encodeExample addressExample}, and

\begin{code}
roleExample :: Party
roleExample = Role "example role"
\end{code}
\par

is serialized as \eval{encodeExample roleExample}

\isamarkupsection{Token}

The \emph{Token} type is serialized as an object with two properties, \emph{currency\_symbol} and
\emph{token\_name}


\begin{code}

instance ToJSON Token where
  toJSON (Token currSym tokName) = object
      [ "currency_symbol" .= currSym
      , "token_name" .= tokName
      ]


instance FromJSON Token where
  parseJSON = withObject "Token"
    (\v ->
       Token <$> (v .: "currency_symbol")
             <*> (v .: "token_name")
    )

\end{code}

for example, the following \emph{Token}

\begin{code}

dolarToken :: Token
dolarToken = Token "85bb65" "dolar"
\end{code}

is serialized as \eval{encodeExample dolarToken}

\isamarkupsection{Payee}

Payees are serialized as a simple object with an \emph{account} or \emph{party} key, depending on the
\emph{Payee} type.
\par

\begin{code}
instance ToJSON Payee where
    toJSON (Account account) =
        object ["account" .= account]
    toJSON (Party party) =
        object ["party" .= party]

instance FromJSON Payee where
    parseJSON = withObject "Payee" $
        \v -> asAccount v <|> asParty v
      where
      asAccount v = Account <$> v .: "account"
      asParty v = Party <$> v .: "party"

\end{code}

for example, the following \emph{Payee}

\begin{code}
internalPayeeExample :: Payee
internalPayeeExample = Account addressExample
\end{code}

is serialized as \eval{encodeExample internalPayeeExample}, and

\begin{code}
externalPayeeExample :: Payee
externalPayeeExample = Party roleExample
\end{code}
\par

is serialized as \eval{encodeExample externalPayeeExample}

\isamarkupsection{ChoiceId}

The \emph{ChoiceId} type is serialized as an object with two properties, \emph{choice\_name} and
\emph{choice\_owner}


\begin{code}

instance ToJSON ChoiceId where
  toJSON (ChoiceId name party) = object
      [ "choice_name" .= name
      , "choice_owner" .= party
      ]


instance FromJSON ChoiceId where
  parseJSON = withObject "ChoiceId"
    (\v ->
       ChoiceId <$> (v .: "choice_name")
                <*> (v .: "choice_owner")
    )

\end{code}

for example, the following \emph{ChoiceId}

\begin{code}
choiceExample :: ChoiceId
choiceExample = ChoiceId "ada price" addressExample
\end{code}


is serialized as

\perform{prettyEncodeExample choiceExample}

\isamarkupsection{Values}

The \emph{ValueId} type is serialized as a literal string.

\begin{code}
instance ToJSON ValueId where
    toJSON (ValueId x) = toJSON x

instance FromJSON ValueId where
    parseJSON = withText "ValueId" $ return . ValueId . T.unpack
\end{code}

The \emph{Value} serialization depends on the constructor. A \emph{Constant}
is serialized as a \emph{number}, \emph{TimeIntervalStart} and \emph{TimeIntervalEnd} are serialized as literal
strings, and the rest are serialized as a single object (with keys depending on the constructor).

\begin{code}
instance ToJSON Value where
  toJSON (AvailableMoney accountId token) = object
      [ "amount_of_token" .= token
      , "in_account" .= accountId
      ]
  toJSON (Constant (Int_of_integer x)) = toJSON x
  toJSON (NegValue x) = object
      [ "negate" .= x ]
  toJSON (AddValue lhs rhs) = object
      [ "add" .= lhs
      , "and" .= rhs
      ]
  toJSON (SubValue lhs rhs) = object
      [ "value" .= lhs
      , "minus" .= rhs
      ]
  toJSON (MulValue lhs rhs) = object
      [ "multiply" .= lhs
      , "times" .= rhs
      ]
  toJSON (DivValue lhs rhs) = object
      [ "divide" .= lhs
      , "by" .= rhs
      ]
  toJSON (ChoiceValue choiceId) = object
      [ "value_of_choice" .= choiceId ]
  toJSON TimeIntervalStart = JSON.String $ T.pack "time_interval_start"
  toJSON TimeIntervalEnd = JSON.String $ T.pack "time_interval_end"
  toJSON (UseValue valueId) = object
      [ "use_value" .= valueId ]
  toJSON (Cond obs tv ev) = object
      [ "if" .= obs
      , "then" .= tv
      , "else" .= ev
      ]

instance FromJSON Value where
  parseJSON (JSON.Object v) =
        (AvailableMoney <$> (v .: "in_account")
                        <*> (v .: "amount_of_token"))
    <|> (NegValue <$> (v .: "negate"))
    <|> (AddValue <$> (v .: "add")
                  <*> (v .: "and"))
    <|> (SubValue <$> (v .: "value")
                  <*> (v .: "minus"))
    <|> (MulValue <$> (v .: "multiply")
                  <*> (v .: "times"))
    <|> (DivValue <$> (v .: "divide") <*> (v .: "by"))
    <|> (ChoiceValue <$> (v .: "value_of_choice"))
    <|> (UseValue <$> (v .: "use_value"))
    <|> (Cond <$> (v .: "if")
              <*> (v .: "then")
              <*> (v .: "else"))
  parseJSON (JSON.String "time_interval_start") = return TimeIntervalStart
  parseJSON (JSON.String "time_interval_end") = return TimeIntervalEnd
  parseJSON (JSON.Number n) = Constant <$> getInteger "constant value" n
  parseJSON _ = fail "Value must be either a string, object or an integer"

\end{code}

Some examples for each \emph{Value}s type

\isamarkupsubsubsection{Constant}

\begin{code}
constantExample :: Value
constantExample = Constant 1
\end{code}

is serialized as \eval{encodeExample constantExample}

\isamarkupsubsubsection{TimeIntervalStart}

\begin{code}
intervalStartExample :: Value
intervalStartExample = TimeIntervalStart
\end{code}

is serialized as \eval{encodeExample intervalStartExample}

\isamarkupsubsubsection{TimeIntervalEnd}

\begin{code}
intervalEndExample :: Value
intervalEndExample = TimeIntervalEnd
\end{code}

is serialized as \eval{encodeExample intervalEndExample}

\isamarkupsubsubsection{AddValue}

\begin{code}
addExample :: Value
addExample = AddValue (Constant 1) (Constant 2)
\end{code}

is serialized as \eval{encodeExample addExample}


\isamarkupsubsubsection{SubValue}

\begin{code}
subExample :: Value
subExample = SubValue (Constant 4) (Constant 2)
\end{code}

is serialized as \eval{encodeExample subExample}


\isamarkupsubsubsection{MulValue}

\begin{code}
mulExample :: Value
mulExample = MulValue (Constant 3) (Constant 6)
\end{code}

is serialized as \eval{encodeExample mulExample}


\isamarkupsubsubsection{DivValue}

\begin{code}
divExample :: Value
divExample = DivValue (Constant 8) (Constant 4)
\end{code}

is serialized as \eval{encodeExample divExample}

\isamarkupsubsubsection{NegValue}

\begin{code}
negateExample :: Value
negateExample = NegValue (Constant 3)
\end{code}

is serialized as \eval{encodeExample negateExample}

\isamarkupsubsubsection{ChoiceValue}

\begin{code}
choiceValueExample :: Value
choiceValueExample = ChoiceValue choiceExample
\end{code}

is serialized as \perform{prettyEncodeExample choiceValueExample}

\isamarkupsubsubsection{UseValue}

\begin{code}
useValueExample :: Value
useValueExample = UseValue (ValueId "variable name")
\end{code}

is serialized as \eval{encodeExample useValueExample}

\isamarkupsubsubsection{Cond}

\begin{code}
condExample :: Value
condExample = Cond TrueObs addExample mulExample
\end{code}

is serialized as \perform{prettyEncodeExample condExample}

\isamarkupsubsubsection{AvailableMoney}

\begin{code}
availableMoneyExample :: Value
availableMoneyExample = AvailableMoney addressExample dolarToken
\end{code}

is serialized as \perform{prettyEncodeExample availableMoneyExample}

\isamarkupsection{Observation}

The \emph{Observation} type is serialized as native boolean (for \emph{TrueObs} and \emph{FalseObs}) or as an object with different properties, depending on the constructor.

\begin{code}
instance ToJSON Observation where
  toJSON (AndObs lhs rhs) = object
      [ "both" .= lhs
      , "and" .= rhs
      ]
  toJSON (OrObs lhs rhs) = object
      [ "either" .= lhs
      , "or" .= rhs
      ]
  toJSON (NotObs v) = object
      [ "not" .= v ]
  toJSON (ChoseSomething choiceId) = object
      [ "chose_something_for" .= choiceId ]
  toJSON (ValueGE lhs rhs) = object
      [ "value" .= lhs
      , "ge_than" .= rhs
      ]
  toJSON (ValueGT lhs rhs) = object
      [ "value" .= lhs
      , "gt" .= rhs
      ]
  toJSON (ValueLT lhs rhs) = object
      [ "value" .= lhs
      , "lt" .= rhs
      ]
  toJSON (ValueLE lhs rhs) = object
      [ "value" .= lhs
      , "le_than" .= rhs
      ]
  toJSON (ValueEQ lhs rhs) = object
      [ "value" .= lhs
      , "equal_to" .= rhs
      ]
  toJSON TrueObs = toJSON True
  toJSON FalseObs = toJSON False


instance FromJSON Observation where
  parseJSON (JSON.Bool True) = return TrueObs
  parseJSON (JSON.Bool False) = return FalseObs
  parseJSON (JSON.Object v) =
        (AndObs <$> (v .: "both")
                <*> (v .: "and"))
    <|> (OrObs <$> (v .: "either")
               <*> (v .: "or"))
    <|> (NotObs <$> (v .: "not"))
    <|> (ChoseSomething <$> (v .: "chose_something_for"))
    <|> (ValueGE <$> (v .: "value")
                 <*> (v .: "ge_than"))
    <|> (ValueGT <$> (v .: "value")
                 <*> (v .: "gt"))
    <|> (ValueLT <$> (v .: "value")
                 <*> (v .: "lt"))
    <|> (ValueLE <$> (v .: "value")
                 <*> (v .: "le_than"))
    <|> (ValueEQ <$> (v .: "value")
                 <*> (v .: "equal_to"))
  parseJSON _ = fail "Observation must be either an object or a boolean"
\end{code}

Some examples for each \emph{Observation} type

\isamarkupsubsubsection{TrueObs}

\begin{code}
trueExample :: Observation
trueExample = TrueObs
\end{code}

is serialized as \eval{encodeExample trueExample}

\isamarkupsubsubsection{FalseObs}

\begin{code}
falseExample :: Observation
falseExample = FalseObs
\end{code}

is serialized as \eval{encodeExample falseExample}

\isamarkupsubsubsection{AndObs}

\begin{code}
andExample :: Observation
andExample = AndObs TrueObs FalseObs
\end{code}

is serialized as \eval{encodeExample andExample}

\isamarkupsubsubsection{OrObs}

\begin{code}
orExample :: Observation
orExample = OrObs TrueObs FalseObs
\end{code}

is serialized as \eval{encodeExample orExample}

\isamarkupsubsubsection{NotObs}

\begin{code}
notExample :: Observation
notExample = NotObs TrueObs
\end{code}

is serialized as \eval{encodeExample notExample}


\isamarkupsubsubsection{ChoseSomething}

\begin{code}
choseExample :: Observation
choseExample = ChoseSomething choiceExample
\end{code}

is serialized as
\perform{prettyEncodeExample choseExample}


\isamarkupsubsubsection{ValueGE}

\begin{code}
valueGEExample :: Observation
valueGEExample = ValueGE (Constant 1) (Constant 2)
\end{code}

is serialized as \eval{encodeExample valueGEExample}


\isamarkupsubsubsection{ValueGT}

\begin{code}
valueGTExample :: Observation
valueGTExample = ValueGT (Constant 1) (Constant 2)
\end{code}

is serialized as \eval{encodeExample valueGTExample}


\isamarkupsubsubsection{ValueLT}

\begin{code}
valueLTExample :: Observation
valueLTExample = ValueLT (Constant 1) (Constant 2)
\end{code}

is serialized as \eval{encodeExample valueLTExample}


\isamarkupsubsubsection{ValueLE}

\begin{code}
valueLEExample :: Observation
valueLEExample = ValueLE (Constant 1) (Constant 2)
\end{code}

is serialized as \eval{encodeExample valueLEExample}


\isamarkupsubsubsection{ValueEQ}

\begin{code}
valueEQExample :: Observation
valueEQExample = ValueEQ (Constant 1) (Constant 2)
\end{code}

is serialized as \eval{encodeExample valueEQExample}


\isamarkupsection{Parse utils}

These are some Aeson utils to help parse a number to the Isabelle exported \emph{Arith\.Int}

\begin{code}
getInteger :: String -> Scientific -> Parser Arith.Int
getInteger ctx x = case (floatingOrInteger x :: Either Double Integer) of
                 Right a -> return $ Int_of_integer a
                 Left _  -> fail $ "parsing " ++ ctx ++ " failed, expected integer, but encountered floating point"

withInteger :: String -> JSON.Value -> Parser Arith.Int
withInteger ctx = withScientific ctx $ getInteger ctx
\end{code}