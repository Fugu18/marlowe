== A first example

This tutorial introduces a simple financial contract in pseudocode,
before explaining how it is modified to work in Marlowe, giving the
first example of a Marlowe contract.

=== A simple escrow contract

image:./pix/escrow.png[Escrow]

Suppose that `+alice+` wants to buy a cat from `+bob+`, but neither of
them trusts the other. Fortunately, they have a mutual friend `+carol+`
whom they both trust to be neutral (but not enough to give her the money
and act as an intermediary). They therefore agree on the following
contract, written using simple functional pseudocode. This kind of
contract is a simple example of _escrow_.

[source,haskell]
----
When aliceChoice
     (When bobChoice 
           (If (aliceChosen `ValueEQ` bobChosen)
               agreement
               arbitrate))
----

The contract is described using the _constructors_ of a Haskell data
type. The outermost constructor `+When+` has two arguments: the first is
an _observation_ and the second is another contract. The intended
meaning of this is that _when_ the observation becomes true, the second
contract is activated.

The second contract is itself another `When` – asking for a decision from `+bob+`, but inside that, there is a _choice_: `If` 
`+alice+` and `+bob+` agree on what to do, it is done; if not,  `+carol+` is asked to arbitrate and make a decision.

In fact, we can allow for the option of `+bob+` making the first choice, rather than `+alice+`, and so we offer a _list of cases_ which can be triggered by any of the actions offered:footnote:[Lists in Marlowe are included in square brackets, as in `[2,3,4\]`.]


[source,haskell]
----
  When [ Case aliceChoice
              (When [ Case bobChoice 
                          (If (aliceChosen `ValueEQ` bobChosen)
                             agreement
                             arbitrate) ],
        Case bobChoice
              (When [ Case aliceChoice 
                          (If (aliceChosen `ValueEQ` bobChosen)
                              agreement
                              arbitrate) ]
       ]
----

____
*Exercise*

Think about executing this contract in practice. Suppose that Alice has
already committed some money to the contract. What will happen if Bob chooses not to participate any further?

We have assumed that Alice has already committed her payment, but
suppose that we want to design a contract to ensure that: what would we
need to do to?
____

=== Escrow in Marlowe

Marlowe contracts incorporate extra constructs to ensure that they progress properly. Each time we see a `When`, we need to provide two things

* a _timeout_ after which the contract will progress, and
* the _continuation_ contract to which it progresses.



==== Adding timeouts

First, let us examine how to modify what we have written to take care of
the case that the condition of the `+When+` never becomes true. So, we  add two values to each of the three `When`s in the contract.

[source,haskell]
----
  When [ Case aliceChoice
              (When [ Case bobChoice 
                          (If (aliceChosen `ValueEQ` bobChosen)
                             agreement
                             arbitrate) ]
                    60            -- ADDED
                    arbitrate),   -- ADDED
        Case bobChoice
              (When [ Case aliceChoice 
                          (If (aliceChosen `ValueEQ` bobChosen)
                              agreement
                              arbitrate) ]
                    60            -- ADDED
                    arbitrate)    -- ADDED
        ]
        40            -- ADDED
        Refund        -- ADDED
----

The outermost `When` calls for the first choice to be made by Alice or Bob: if neither of them has made a choice by time `40`, all the funds in the contract are refunded. 

`Refund` is typically the last step in each of the alternatives in a Marlowe contract, and its effect is to refund the money in the contract to the participants; we will describe this in more detail in a later tutorial. Refund will happen after `40` slots.

Looking at the inner constructs, if a choice has been made, then we wait for a second one. If that is not forthcoming by slot `60`, the Carol is called upon to arbitrate.footnote:[Again, we will describe how `arbitrate` works in a later tutorial.]



==== Adding commitments

Next, we should look at how _cash is committed_ as the first step of the
contract.

[source,haskell]
----
Commit iCC1 alice (Constant 450) 10 100  -- ADDED
                  (When (OrObs (two_chose alice bob carol refund)
                               (two_chose alice bob carol pay))
                        90
                        (Choice (two_chose alice bob carol pay)
                                (Pay iCC1 bob (Committed iCC1) 100 Null Null)
                                redeem_original)
                        redeem_original)
        Null                               -- ADDED
----

The commitment requested from `+alice+` is given an identifier,
`+iCC1+`. The cash value (`+450+`) and timeout (`+100+`) on the
commitment are also specified. Moreover, a _timeout on making the
commitment_, `+10+`, is specified as part of the contract, too, as well
as a contract to be followed if the commitment is not forthcoming: that
is `+Null+` in this case.

==== Identifiers

Finally, we have to add _action identifiers_ to each instance of an
action, that is to each `+Commit+` and `+Pay+`. These action ids, which
could be generated automatically by an implementation of Marlowe, must
occur once only in each contract. Their role is to allow inputs, such as
commitments of cash by a participant, to be linked to a unique point in
the contract.

We will see link:./embedded-marlowe.md[later] that parts of this
contract description, such as `+redeem_original+`, use the Haskell
embedding of Marlowe to give some shorthand definitions. In this case
the redemption is defined in terms of `+Pay+` and so id’s need to be
supplied to that construct too. With identifiers, the full contract
becomes

[source,haskell]
----
Commit 1 iCC1 alice (Constant 450) 10 100           -- +1
                  (When (OrObs (two_chose alice bob carol refund)
                               (two_chose alice bob carol pay))
                        90
                        (Choice (two_chose alice bob carol pay)
                                (Pay 2 iCC1 bob (Committed iCC1) 100 Null Null) -- +2
                                redeem_original 3) -- +3
                        redeem_original 4)         -- +4
        Null                              
----

Just to recap, why have we included identifiers in commitments and
payments, in this case `+iCC1+` and `+iP1+`? The identifier is used to
identify the commit in a `+RedeemCC+` or in a `+Both+` construct to
identify a payment or commitment. In the former case to clarify what is
being redeemed, and in the latter to distinguish between constructs in
the two branches of a `+Both+`. For a contract to be properly
constructed, identifiers need to be unique: i.e they need to identify a
single construct only.

____
*Exercise*

Comment on the choice of timeout values, and look at alternatives. For
example, what would happen if the timeout on the `+When+` (`+90+`) were
to be replaced by `+110+`? Is it sensible to have the same timeout
(`+100+`) on both the commitment and the payment? If not, what choice
would you make?
____

This example has shown many of the ingredients of the Marlowe contract
language; in the next tutorial we will present the complete language.

==== Notes

* Many of the items used here, including, for example `+alice+` and
`+two_chose+`, and defined using the embedded DSL, which is discussed in
more detail when we look at link:./embedded-marlowe.md[embedded
Marlowe].
* While identifiers need to be provided manually in the example here,
these could be generated by users’ wallets in a version of Marlowe
deployed on a blockchain.

=== Where to go to find out more

* https://www.microsoft.com/en-us/research/publication/composing-contracts-an-adventure-in-financial-engineering/[Composing
contracts: an adventure in financial engineering]
* https://dl.acm.org/citation.cfm?id=2784747[Certified symbolic
management of financial multi-party contracts]

==== link:./introducing-marlowe.adoc[Prev] link:./README.adoc[Up] link:./marlowe-model.adoc[Next]
