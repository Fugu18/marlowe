== Marlowe and its components as Haskell data types

This tutorial formally introduces Marlowe as a Haskell data type, as well as presenting 
the different types used by the model, and discussing a
number of assumptions about the infrastructure in which contracts will
be run. The code that we describe here comes from the Haskell modules https://github.com/input-output-hk/marlowe/blob/master/semantics-3.0/src/Language/Marlowe/Semantics.hs[Semantics.hs] and https://github.com/input-output-hk/marlowe/blob/master/semantics-3.0/src/Language/Marlowe/Util.hs[Util.hs].

=== Marlowe

The Marlowe domain-specific language (DSL) is modelled as a collection of  algebraic
types in Haskell, with contracts being given by the `Contract` type:

[source,haskell]
----
data Contract = Refund
              | Pay AccountId Payee Value Contract
              | If Observation Contract Contract
              | When [Case] Timeout Contract
              | Let ValueId Value Contract
----

We saw link:./marlowe-step-by-step.adoc[in the previous tutorial] what these contracts do. In the rest of this tutorial we will dig a bit deeper into the Haskell types that are used to represent the various components of the contracts, including accounts, values, observations, and actions. We will also look at types that relate to the execution of contracts, including inputs, states, the environment. 

=== Basic components

In modelling basic parts of Marlowe we use a combination of Haskell `data` types, that define _new_ types, and `type` synonyms that give a new name to an existing type.footnote:[In fact we used `newtype` declarations rather than `data` types because they are more efficiently implemented.] So, members of `PubKey` and `Party` will look like `(PubKey "alice")`, `(PubKey "bob")` and so on. 
[source,haskell]
----
data PubKey = PubKey Text
type Party  = PubKey   
----
However, Haskell allows us to present and read in these values more concisely (by declaring a custom instance of `Show` and using _overloaded strings_) so that these can be input and read as `"alice"`, `"bob"` etc. Because `Party` is a synonym for `PubKey`, the same applies to parties to contracts. 

Slot numbers and amounts of money are treated in a similar way; with the same show/overload approach they will appear in contracts as numbers:

[source,haskell]
----
data Slot    = Slot Integer
type Timeout = Slot

data Ada     = Lovelace Integer 
type Money   = Ada
----
Accounts have a number `NumAccount` and an owner, who is a `Party` to the contract.
[source,haskell]
----
type NumAccount = Integer
data AccountId  = AccountId NumAccount Party
----
and an example would be `AccountId 0 "alice"`. Note that `"alice"` is the owner here in the sense that she will be refunded any money in the account when the contract terminates. 

Because in many contracts, each party will own at most one account, we can use overloaded strings to allow us to abbreviate this account – account number `0` for any owner – by the name of its owner: in this case `"alice"`. 

A payment can be made to one of the parties to the contract, or to one of the accounts of the contract, and this is reflected in the definition

[source,haskell]
----
data Payee = Account AccountId
           | Party Party
----

Choices – of integers – are identified by `ChoiceId` which combines a name for the choice with the `Party` who had made the choice:
[source,haskell]
----
type ChoiceName = Text    
data ChoiceId   = ChoiceId ChoiceName Party
type ChosenNum  = Integer
----
Values, as defined using `Let` are also identified by integers.footnote:[This may be modified in the future to allow values to be named by strings.] 
[source,haskell]
----
data ValueId    = ValueId Integer
----

=== Values, observations and actions

Building on the basic types, we can describe three higher-level components of contracts: a type of _values_, on top of that a type of _observations_, and also a type of _actions_, which trigger particular cases. First, looking at `Value` we have

[source,haskell]
----
data Value = AvailableMoney AccountId
           | Constant Integer
           | NegValue Value
           | AddValue Value Value
           | SubValue Value Value
           | ChoiceValue ChoiceId Value
           | SlotIntervalStart
           | SlotIntervalEnd
           | UseValue ValueId
----
The different kinds of values – all of which are `Integer` – are pretty much self explanatory, but for completeness we have

* Lookup of the value in an account `AvailableMoney`, made in a choice `ChoiceValue` and in an identifier that has already been defined  `UseValue`.
* Arithmetic constants and operators.
* The start and end of the current _slot interval_; see below for further discussion of this.

Next we have observations 

[source,haskell]
----
data Observation = AndObs Observation Observation
                 | OrObs Observation Observation
                 | NotObs Observation
                 | ChoseSomething ChoiceId
                 | ValueGE Value Value
                 | ValueGT Value Value
                 | ValueLT Value Value
                 | ValueLE Value Value
                 | ValueEQ Value Value
                 | TrueObs
                 | FalseObs
----

These are really self-explanatory: we can compare values for (in)equality and ordering, and combine observations using the Boolean connectives. The only other construct `ChoseSomething` indicates whether any choice has been made for a given `ChoiceId`.

Cases and actions are given by these types:

[source,haskell]
----
data Case = Case Action Contract

data Action = Deposit AccountId Party Value
            | Choice ChoiceId [Bound]
            | Notify Observation

data Bound = Bound Integer Integer
----
Three kinds of action are possible: 

* A `Deposit n p v` makes a deposit of value `v` into account number `n` belonging to party `p`.is made into account number 
* A choice is made for a particular id with a list of bounds on the values that are acceptable.  For example, `[Bound 0 0, Bound 3 5]` offers the choice of one of `0`, `3`, `4` and `5`.
* The contract is notified that a particular observation be made. Typically this would be done by one of the parties, or one of their wallets acting automatically.

This completes our discussion of the types that make up Marlowe contracts.

=== Dynamic data

to do

=== Slot ranges

to do

==== Notes

The model makes a number of assumptions about the blockchain
infrastructure in which it is run.

* It is assumed that cryptographic functions and operations are provided
by a layer external to Marlowe, and so they need not be modelled
explicitly.
* We assume that time is ``coarse grained'' and measured by block or
slot number, so that, in particular, timeouts are delimited using
block/slot numbers.
* Making a deposit is not something that a contract can perform;
rather, it can request that a deposit is made, but that then has to
be established externally: hence the input of (a collection of) deposits for
each transaction.
* The model manages the refund of funds back to the person owning a particular account when a
contract reaches the point of `Refund`.

For ease of reading, in the `+data+` type definition at the start of
this section, we omit the `+!+` symbol before every field of all
constructors. This makes them strict in that field. We choose to make
Marlowe strict in all arguments to all constructors, so that Marlowe
contracts are wholly _finite_ data structures, with no partial or
infinite components.

==== link:./marlowe-step-by-step.adoc[Prev] link:./README.adoc[Up] link:./marlowe-semantics.adoc[Next]
